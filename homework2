######### #HOMEWORK 2 #######

###Part 1###

#Global alignment

def dist_global(char1, char2):
    """
    Function that computes the distance between two characters in a sequence,
    used for global alignment.
    
    # Input arguments:
    char1, char2 = Values of 2 characters, either nucleobases or gaps, as 1-character strings.
    
    E.g. char1 = 'A', char2 = 'G'
         char1 = 'A', char2 = '-'

    # Returns:
    The distance (or cost of change) between char1 and char2, using the DIST_... values
    """
    
    DIST_MATCH = 0
    DIST_GAP = 8
    DIST_TRANSITION = 2
    DIST_TRANSVERSION = 4
    
    if char1 == char2:
        return DIST_MATCH

    if char1 == '-' or char2 == '-':
        return DIST_GAP

    if (char1 == 'A' and char2 == 'G') or (char1 == 'G' and char2 == 'A'):
        return DIST_TRANSITION

    if (char1 == 'C' and char2 == 'T') or (char1 == 'T' and char2 == 'C'):
        return DIST_TRANSITION

    else:
        return DIST_TRANSVERSION


import numpy as np

def global_alignment_matrix(seq1, seq2):
    """
    Computes the global alignment matrix D between 
    sequences seq1 and seq2
    
    Input:
    seq1, seq2 = nucleobase sequences as strings
    
    E.g. seq1 = 'TATACCTGAAGGGCCT', seq2 = 'TATACGAGACCGTTT'
    
    Returns:
    D = global alignment matrix as 2D numpy array
    """
    DIST_MATCH = 0
    DIST_GAP = 8
    DIST_TRANSITION = 2
    DIST_TRANSVERSION = 4

    # Initialize the matrix with all zero values
    # (and enforce use of integers, since numpy works with floats by default)
    D = np.zeros((len(seq1) + 1, len(seq2) + 1), dtype=int)
    
    # Initialize horizontal (top) boundary of D using seq1
    for i in range(1, len(seq1) + 1):
        D[i, 0] = i*DIST_GAP
        
    # Initialize vertical (left) boundary of D using seq2
    for j in range(1, len(seq2) + 1):
        D[0, j] = j*DIST_GAP
    
    # Walk through all cells of the matrix,
    # updating the current cell by considering a step from 3 possible directions,
    # and taking the least "costly" of these 3 directions (shortest distance).
    for i in range(1, len(seq1) + 1):
        for j in range(1, len(seq2) + 1):
            
            dist_from_upper_left = dist_global(seq1[i-1], seq2[j-1]) #match/mismatch
            dist_from_above      = dist_global(seq1[i-1], '-') #gap in seq2
            dist_from_left       = dist_global('-', seq2[j-1]) #gap in seq1
            
            D[i, j] = min(D[i-1, j-1] + dist_from_upper_left,
                          D[i-1, j  ] + dist_from_above,
                          D[i  , j-1] + dist_from_left)
    return D

def global_alignment_value(global_alignment_matrix):
    """
    Input:
    global_alignment_matrix = a computed global alignment matrix as a numpy array
    
    Returns:
    The lower-right corner of the matrix, since we know that holds
    the global alignment value
    """
    lower_right_corner = (global_alignment_matrix.shape[0] - 1, #number of rows in matrix minus 1
                          global_alignment_matrix.shape[1] - 1) #number of cols in matrix minus 1
    return global_alignment_matrix[lower_right_corner]
    

#Local alignment
def dist_local_example(char1, char2):
    """
    Function that computes the distance between two characters in a sequence,
    used for local alignment.
    
    # Input arguments:
    char1, char2 = Values of 2 characters, either nucleobases or gaps, as 1-character strings.
    
    E.g. char1 = 'A', char2 = 'G'
         char1 = 'A', char2 = '-'

    # Returns:
    The distance (or cost of change) between char1 and char2, using the DIST_... values
    """
    
    DIST_MATCH = 2
    DIST_GAP = -6
    DIST_MISMATCH = -4
    
    if char1 == char2:
        return DIST_MATCH
    
    if char1 == '-' or char2 == '-':
        return DIST_GAP
    
    else:
        return DIST_MISMATCH
        
        
 def local_alignment_matrix(seq1, seq2):
    """
    Computes the local alignment matrix D between 
    sequences seq1 and seq2
    
    Input:
    seq1, seq2 = nucleobase sequences as strings
    
    E.g. seq1 = 'TATACCTGA', seq2 = 'TATACGAGACCGTTT'
    
    Returns:
    D = local alignment matrix as 2D numpy array
    """

    # Initialize the matrix with all zero values
    D = np.zeros((len(seq1) + 1, len(seq2) + 1), dtype=int)
    
    # Walk through all cells of the matrix,
    # updating the current cell by considering a step from 3 possible directions,
    # and taking the max of scores corresponding 3 directions.
    for i in range(1, len(seq1) + 1):
        for j in range(1, len(seq2) + 1):
            
            dist_from_upper_left = dist_local_example(seq1[i-1], seq2[j-1]) #match/mismatch
            dist_from_above = dist_local_example(seq1[i-1],'-') #gap in seq1
            dist_from_left = dist_local_example('-',seq2[j-1]) #gap in seq2
            
            D[i, j] = max(D[i-1, j-1] + dist_from_upper_left,
                          D[i-1, j  ] + dist_from_above,
                          D[i  , j-1] + dist_from_left,
                          0)
                          # make sure to have a non-negative value since this is a distance
    return D


def local_alignment_value(alignment_matrix):
    """
    Input:
    global_alignment_matrix = a computed local alignment matrix as a numpy array
    
    Returns:
    The max value of the matrix since we know this 
    """
    return alignment_matrix.max()


###Part 2###

###Part 3###
